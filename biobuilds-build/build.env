#------------------------------------------------------------------------------
# Script that sets various environment variables used for building BioBuilds
# packages with "conda build". These are mostly compiler and other toolchain
# flags that enable more aggressive and/or architecture-specific optimizations.
#------------------------------------------------------------------------------

# Sanity check script usage
if [ "$0" == "$BASH_SOURCE" ]; then
    echo "ERROR: '$0' must be sourced; use 'source $0' instead." >&2
    exit 1
fi
if [ -z "$BASH_VERSION" ]; then
    echo "ERROR: '$0' currently only supports the bash shell." >&2
    return
fi


# Generate an error if trying to build packages with the 'opt'-feature using
# the $FEATURE_OPT environment variable instead of conda build variants. In
# theory, we could try to maintain backwards compatibility and deal with this,
# but nailing down all corner cases caused by mixing $FEATURE_* environment
# variables and recipe-specified build variants is probably not worth the pain.
if [[ -z "${toolchain}" && "${FEATURE_OPT:-0}" -eq 1 || "${OPT:-0}" -eq 1 ]]; then
    echo "*** ERROR: Building 'opt'-featured packages using the \$FEATURE_OPT" >&2
    echo "*** ERROR: environment variable is no supported. Please use 'toolchain'" >&2
    echo "*** ERROR: conda build variants instead." >&2
    exit 1
fi


# Set umask to help ensure world-readable package files
umask 022


# Get the platform(s) we're building on (BUILD_*) and for (HOST_*)
: ${BUILD_ARCH:=$(uname -m | tr A-Z a-z)}
: ${BUILD_OS:=$(uname -s | tr A-Z a-z)}
: ${HOST_ARCH:=${BUILD_ARCH}}
: ${HOST_OS:=${BUILD_OS}}
export BUILD_ARCH BUILD_OS
export HOST_ARCH HOST_OS


# If not defined, use all avaialable CPUs for building packages
: ${CPU_COUNT:=1}
: ${MAKE_JOBS:=${CPU_COUNT}}
export MAKE_JOBS


# Save the values of various environment variables set by conda.
for var in \
    CPP CPPFLAGS DEBUG_CPPFLAGS \
    CC CFLAGS DEBUG_CFLAGS \
    CXX CXXFLAGS DEBUG_CXXFLAGS \
    FC F90 F95 FCFLAGS DEBUG_FCFLAGS \
    FORTRANFLAGS DEBUG_FORTRANFLAGS \
    F77 FFLAGS DEBUG_FFLAGS \
    AR LD LDFLAGS;
do
    eval export CONDA_${var}="\${!var}"
done


# Use the following logic to choose a "reasonable" set of compilers:
#
# - If using the "new" (Anaconda 5.0+) toolchain packages, compiler-selecting
#   environment variables like ${CC} and ${CXX} should be set when the build
#   environment is activated, so this section should effectively be a no-op.
# - If the build environment contains the older gcc-4.8 conda package, use that
#   as our preferred toolchain.
# - If conda toolchain packages are not installed, fallback to the standard
#   toolchain provided by the OS vendor.
if [[ -x "${PREFIX}/bin/gcc" ]]; then
    : ${CPP:="${PREFIX}/bin/cpp"}
    : ${CC:="${PREFIX}/bin/gcc"}
    : ${CXX:="${PREFIX}/bin/g++"}
    : ${FC:="${PREFIX}/bin/gfortran"}
    : ${F77:=}
else
    case "$HOST_OS" in
        "darwin")
            : ${CPP:="/usr/bin/cpp"}
            : ${CC:="/usr/bin/clang"}
            : ${CXX:="/usr/bin/clang++"}

            # Apple Xcode no longer includes a Fortran compiler. If the conda
            # "gcc" package is not installed, then responsibility for managing
            # which Fortran compiler to use falls on the sourcing "build.sh".
            : ${FC:=}
            : ${F77:=}
        ;;
        "linux")
            : ${CPP:="/usr/bin/cpp"}
            : ${CC:="/usr/bin/gcc"}
            : ${CXX:="/usr/bin/g++"}
            : ${FC:="/usr/bin/gfortran"}
            : ${F77:=}
            ;;
    esac
fi


# Default to using the system-provided archiver and linker. The conda gcc-4.8
# package doesn't include a linker, so this is a reasonably safe choice.
#
# NOTE: The "binutils" packages introduced in Anaconda 5.0 should set these
# environment variables when the build environment are activated, so this
# section is effectively a no-op when using those packages.
: ${AR:="/usr/bin/ar"}
: ${LD:="/usr/bin/ld"}


# "Hacky" way of checking if various compilers are actually the GNU variants
test -x "${CC:-/dev/null}" && \
    CC_IS_GNU=$("${CC}" --version 2>&1 | egrep -qi 'clang|llvm|intel|pgi'; echo $?) ||
    CC_IS_GNU=
test -x "${CXX:-/dev/null}" && \
    CXX_IS_GNU=$("${CXX}" --version 2>&1 | egrep -qi 'clang|llvm|intel|pgi'; echo $?) ||
    CXX_IS_GNU=
test -x "${FC:-/dev/null}" && \
    FC_IS_GNU=$("${FC}" --version 2>&1 | egrep -qi 'clang|llvm|intel|pgi'; echo $?) ||
    FC_IS_GNU=


# Set "reasonable" defaults for toolchain environment variables
: ${CPPFLAGS:=}
: ${CFLAGS:=-fPIC}
: ${DEBUG_CFLAGS:=-fPIC -g}
: ${CXXFLAGS:=-fPIC}
: ${DEBUG_CXXFLAGS:=-fPIC -g}
: ${FCFLAGS:="-fPIC"}
: ${DEBUG_FCFLAGS:="-fPIC -g"}
: ${FORTRANFLAGS:=-fPIC}
: ${DEBUG_FORTRANFLAGS:=-fPIC}
: ${FFLAGS:=-fPIC}
: ${DEBUG_FFLAGS:=-fPIC -g}
: ${F77FLAGS:=}
: ${DEBUG_F77FLAGS:=-g}
: ${LDFLAGS:=}


# Remove certain flags set by Anaconda's toolchain packages since we'll be
# providing our own values. In theory, the compilers should be smart enough to
# handle multiple values of these arguments (e.g., providing "-O2 -O3" in the
# same command line), but letting them do so makes it harder for humans to
# understand what exactly is going on when building recipes.
declare -a keep_flags
for var in \
    CPPFLAGS DEBUG_CPPFLAGS \
    CFLAGS DEBUG_CFLAGS \
    CXXFLAGS DEBUG_CXXFLAGS \
    FCFLAGS DEBUG_FCFLAGS \
    FORTRANFLAGS DEBUG_FORTRANFLAGS \
    FFLAGS DEBUG_FFLAGS \
    LDFLAGS;
do
    keep_flags=()
    for flag in ${!var}; do
        case $flag in
            # Drop these flags...
            -std=*) ;;                      # Language standards
            -march=*|-mcpu=*|-mtune=*) ;;   # Architecture/CPU targets
            -O*) ;;                         # Standard optimization levels

            # ...and keep all other flags
            *) keep_flags+=($flag) ;;
        esac
    done
    eval ${var}="\${keep_flags[@]}"
    export ${var}
done
unset keep_flags


# Architecture-specific flags (mostly for optimizations)
: ${ARCH_FLAGS:=}
case "$HOST_ARCH" in
    "x86_64")
        # Assuming target microarchitecture is Nehalem or later, so we can
        # safely enable SSE4.x instructions; this shouldn't be a _totally_
        # unreasonable assumption since Nehalem was introduced in 2008.
        #
        # ** WARNING **: do *NOT* change "-march" from "core2" to something
        # more recent like "corei7", as those values are not recognized by the
        # stock gcc 4.4.x used by our CentOS 6-based Docker build image.
        ARCH_FLAGS="${ARCH_FLAGS} -m64 -march=core2 -mfpmath=sse"
        ARCH_FLAGS="${ARCH_FLAGS} -mmmx -msse -msse2 -msse3 -mssse3"
        ARCH_FLAGS="${ARCH_FLAGS} -msse4 -msse4.1 -msse4.2 -mpopcnt"
        ;;
    "ppc64le")
        # Assuming microarchitecture is POWER8 or later.
        ARCH_FLAGS="${ARCH_FLAGS} -m64 -mcpu=power8 -mtune=power8"
        ARCH_FLAGS="${ARCH_FLAGS} -maltivec -mvsx"
        ARCH_FLAGS="${ARCH_FLAGS} -mcmodel=medium"
        ;;
    # TODO: flags for ARMv7 (Raspberry Pi 2 and 3)
esac
export ARCH_FLAGS


# "Generic" (i.e., not architecture-specific) optimization flags
: ${OPT_FLAGS:=}
: ${CC_OPT_FLAGS:=}
: ${CXX_OPT_FLAGS:=}
: ${FC_OPT_FLAGS:=}

OPT_FLAGS="${OPT_FLAGS} -O3"


# GNU-specific "generic" optimization flags"
if [[ "$CC_IS_GNU" -eq 1 ]]; then
    CC_OPT_FLAGS="${CC_OPT_FLAGS} -fpeel-loops -funroll-loops"
    CC_OPT_FLAGS="${CC_OPT_FLAGS} -ftree-vectorize -fvect-cost-model"
fi

if [[ "$CXX_IS_GNU" -eq 1 ]]; then
    CXX_OPT_FLAGS="${CXX_OPT_FLAGS} -fpeel-loops -funroll-loops"
    CXX_OPT_FLAGS="${CXX_OPT_FLAGS} -ftree-vectorize -fvect-cost-model"
fi

if [[ "$FC_IS_GNU" -eq 1 ]]; then
    FC_OPT_FLAGS="${FC_OPT_FLAGS} -fpeel-loops -funroll-loops"
    FC_OPT_FLAGS="${FC_OPT_FLAGS} -ftree-vectorize -fvect-cost-model"
fi

export OPT_FLAGS CC_OPT_FLAGS CXX_OPT_FLAGS FC_OPT_FLAGS


# Add "${PREFIX}/include" and '${PREFIX}/lib" to search paths
for var in CPPFLAGS DEBUG_CPPFLAGS \
           CFLAGS DEBUG_CFLAGS \
           CXXFLAGS DEBUG_CXXFLAGS \
           FCFLAGS DEBUG_FCFLAGS \
           FORTRANFLAGS DEBUG_FORTRANFLAGS \
           FFLAGS DEBUG_FFLAGS \
           ; do
    if [[ ${!var} != *-I${PREFIX}/include* ]]; then
        eval ${var}=\"\${!var} -I\${PREFIX}/include\"
    fi
done

for var in LDFLAGS; do
    if [[ ${!var} != *-L${PREFIX}/lib* ]]; then
        eval ${var}=\"\${!var} -L\${PREFIX}/lib\"
    fi
done


# Set the environment variables that control compiler options
CFLAGS="${CFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${CC_OPT_FLAGS}"
CXXFLAGS="${CXXFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${CXX_OPT_FLAGS}"
FCFLAGS="${FCFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${FC_OPT_FLAGS}"
FORTRANFLAGS="${FORTRANFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${FC_OPT_FLAGS}"
FFLAGS="${FFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${FC_OPT_FLAGS}"
F77FLAGS="${F77FLAGS} ${ARCH_FLAGS} ${OPT_FLAGS} ${FC_OPT_FLAGS}"


# Toolchain selection via conda build variants; this mechanism is typically
# used to build optimized binaries using the CPU manufacturer's toolchain
# (Intel Parallel Studio for x86_64 and IBM Advance Toolchain for POWER).
if [[ "${toolchain:-default}" != "default" ]]; then
    # Ignore (unset) the FEATURE_OPT environment variable when build variants.
    # This prevents us from accidentally `source`-ing the legacy build
    # environment configuration files (see below).
    if [[ ! -z "${FEATURE_OPT}" || ! -z "${OPT}" ]]; then
        echo "*** WARNING: Ignoring \$FEATURE_OPT with build variants." >&2
        unset FEATURE_OPT OPT
    fi

    mydir=$(cd `dirname "${BASH_SOURCE[0]}"` && pwd)
    if [ -f "${mydir}/build-${toolchain}.env" ]; then
        source "${mydir}/build-${toolchain}.env"
    else
        echo "*** ERROR: Could not find ${toolchain} environment file." >&2
        exit 1
    fi
fi


# Make toolchain environment variables available in the environment of
# sub-shells and other child processes during the build process.
export CPP CPPFLAGS
export CC CFLAGS
export CXX CXXFLAGS
export FC F90 F95 FCFLAGS FORTRANFLAGS
export F77 F77FLAGS
export AR
export LD LDFLAGS


# If requested, echo out our configured values
if [[ "$1" == "-v" ]]; then
    # Turn off command tracing so the output below doesn't get cluttered up
    if [[ "$-" == *x* ]]; then
        set +x
        restore_x_opt=1
    fi

    echo -e "\n-----  CONFIGURED BUILD ENVIRONMENT  -----"
    for var in BUILD_ARCH BUILD_OS \
        HOST_ARCH HOST_OS \
        CPP CPPFLAGS DEBUG_CPPFLAGS \
        CC CFLAGS DEBUG_CFLAGS \
        CXX CXXFLAGS DEBUG_CXXFLAGS \
        FC F90 F95 FCFLAGS DEBUG_FCFLAGS \
        F77 F77FLAGS DEBUG_F77FLAGS \
        AR LD LDFLAGS \
        CC_IS_GNU CXX_IS_GNU FC_IS_GNU \
        MAKE_JOBS;
    do
        printf '%-10s = %s\n' "${var}" "${!var}"
    done
    echo -e "-----  CONFIGURED BUILD ENVIRONMENT  -----\n"

    # Restore command tracing (if needed)
    if [[ ${restore_x_opt:-0} -eq 1 ]]; then
        unset restore_x_opt
        set -x
    fi
fi
