#------------------------------------------------------------------------------
# Script that sets various environment variables used for building BioBuilds
# packages with "conda build". These are mostly compiler and other toolchain
# flags that enable more aggressive and/or architecture-specific optimizations.
#------------------------------------------------------------------------------

# Sanity check script usage
if [ "$0" == "$BASH_SOURCE" ]; then
    echo "ERROR: '$0' must be sourced; use 'source $0' instead." >&2
    exit 1
fi
if [ -z "$BASH_VERSION" ]; then
    echo "ERROR: '$0' currently only supports the bash shell." >&2
    return
fi


# Set umask to help ensure world-readable package files
umask 022


# Basic information about the platform we're building for
export BUILD_ARCH=$(uname -m | tr A-Z a-z)
export BUILD_OS=$(uname -s | tr A-Z a-z)


# If not defined, use all avaialable CPUs for building packages
: ${CPU_COUNT:=1}
: ${MAKE_JOBS:=${CPU_COUNT}}
export MAKE_JOBS


# If the build environment contains the "gcc" conda package, use that as our
# preferred toolchain. If the "gcc" conda package is not installed, default to
# using the standard toolchain provided by the OS and/or distro vendor.
if [[ -x "${PREFIX}/bin/gcc" ]]; then
    : ${CPP:="${PREFIX}/bin/cpp"}
    : ${CC:="${PREFIX}/bin/gcc"}
    : ${CXX:="${PREFIX}/bin/g++"}
    : ${FC:="${PREFIX}/bin/gfortran"}
    : ${F77:=}
else
    case "$BUILD_OS" in
        "darwin")
            : ${CPP:="/usr/bin/cpp"}
            : ${CC:="/usr/bin/clang"}
            : ${CXX:="/usr/bin/clang++"}

            # Apple Xcode no longer includes a Fortran compiler. If the conda
            # "gcc" package is not installed, then responsibility for managing
            # which Fortran compiler to use falls on the sourcing "build.sh".
            : ${FC:=}
            : ${F77:=}
        ;;
        "linux")
            : ${CPP:="/usr/bin/cpp"}
            : ${CC:="/usr/bin/gcc"}
            : ${CXX:="/usr/bin/g++"}
            : ${FC:="/usr/bin/gfortran"}
            : ${F77:=}
            ;;
    esac
fi

# Default to using the system-provided archiver and linker. The "gcc" conda
# package doesn't include a linker, so this is a reasonably safe choice.
: ${AR:="/usr/bin/ar"}
: ${LD:="/usr/bin/ld"}


# "Hacky" way of checking if "${CC}" is really the GNU compiler
CC_IS_GNU=$("${CC}" --version 2>&1 | grep -qi llvm; echo $?)
export CC_IS_GNU


# Save the values of various set by conda
export CONDA_CFLAGS="${CFLAGS}"
export CONDA_CXXFLAGS="${CXXFLAGS}"
export CONDA_LDFLAGS="${LDFLAGS}"


# Architecture-specific flags (mostly for optimizations)
: ${ARCH_FLAGS:=}
case "$BUILD_ARCH" in
    "x86_64")
        # Assuming target microarchitecture is Nehalem or later, so we can
        # safely enable SSE4.x instructions; this shouldn't be a _totally_
        # unreasonable assumption since Nehalem was introduced in 2008.
        #
        # ** WARNING **: do *NOT* change "-march" from "core2" to something
        # more recent like "corei7", as those values are not recognized by the
        # stock gcc 4.4.x used by our CentOS 6-based Docker build image.
        ARCH_FLAGS="${ARCH_FLAGS} -m64 -march=core2 -mfpmath=sse"
        ARCH_FLAGS="${ARCH_FLAGS} -mmmx -msse -msse2 -msse3 -mssse3"
        ARCH_FLAGS="${ARCH_FLAGS} -msse4 -msse4.1 -msse4.2 -mpopcnt"
        ;;
    "ppc64le")
        # Assuming microarchitecture is POWER8 or later.
        ARCH_FLAGS="${ARCH_FLAGS} -m64 -mcpu=power8 -mtune=power8"
        ARCH_FLAGS="${ARCH_FLAGS} -maltivec -mvsx"
        ARCH_FLAGS="${ARCH_FLAGS} -mcmodel=medium"
        ;;
    # TODO: flags for ARMv7 (Raspberry Pi 2 and 3)
esac
export ARCH_FLAGS


# "Generic" (i.e., not architecture-specific) optimization flags
: ${OPT_FLAGS:=}
OPT_FLAGS="${OPT_FLAGS} -O3"
if [[ "$CC_IS_GNU" -eq 1 ]]; then
    OPT_FLAGS="${OPT_FLAGS} -fpeel-loops -funroll-loops"
    OPT_FLAGS="${OPT_FLAGS} -ftree-vectorize -fvect-cost-model"
fi
export OPT_FLAGS


# Set "reasonable" defaults for toolchain environment variables
: ${CPPFLAGS:=}
: ${CFLAGS:=}
: ${CXXFLAGS:=${CFLAGS}}
: ${FCFLAGS:=}
: ${F77FLAGS:=}
: ${LDFLAGS:=}

CFLAGS="${CFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS}"
CXXFLAGS="${CXXFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS}"
FCFLAGS="${FCFLAGS} ${ARCH_FLAGS} ${OPT_FLAGS}"


# Generate an error if trying to build packages with the 'opt'-feature using
# the $FEATURE_OPT environment variable instead of conda build variants. In
# theory, we could try to maintain backwards compatibility and deal with this,
# but nailing down all corner cases caused by mixing $FEATURE_* environment
# variables and recipe-specified build variants is probably not worth the pain.
if [[ -z "${toolchain}" && "${FEATURE_OPT:-0}" -eq 1 || "${OPT:-0}" -eq 1 ]]; then
    echo "*** ERROR: Building 'opt'-feature using the \$FEATURE_OPT flag is no longer" >&2
    echo "*** ERROR: supported. Please use 'toolchain' conda build variants instead." >&2
    exit 1
fi


# Toolchain selection via conda build variants; this mechanism is typically
# used to build optimized binaries using the CPU manufacturer's toolchain
# (Intel Parallel Studio for x86_64 and IBM Advance Toolchain for POWER).
if [[ "${toolchain:-default}" != "default" ]]; then
    # Ignore (unset) the FEATURE_OPT environment variable when build variants.
    # This prevents us from accidentally `source`-ing the legacy build
    # environment configuration files (see below).
    if [[ ! -z "${FEATURE_OPT}" || ! -z "${OPT}" ]]; then
        echo "*** WARNING: Ignoring \$FEATURE_OPT with build variants." >&2
        unset FEATURE_OPT OPT
    fi

    mydir=$(cd `dirname "${BASH_SOURCE[0]}"` && pwd)
    if [ -f "${mydir}/build-${toolchain}.env" ]; then
        source "${mydir}/build-${toolchain}.env"
    else
        echo "*** ERROR: Could not find ${toolchain} environment file." >&2
        exit 1
    fi
fi


# Add ${PREFIX}/include and ${PREFIX}/lib to search paths
CPPFLAGS="${CPPFLAGS} -I${PREFIX}/include"
CFLAGS="${CFLAGS} -I${PREFIX}/include"
CXXFLAGS="${CXXFLAGS} -I${PREFIX}/include"
LDFLAGS="${LDFLAGS} -L${PREFIX}/lib"


# Make toolchain environment variables available in the environment of
# sub-shells and other child processes during the build process.
export CPP CPPFLAGS
export CC CFLAGS
export CXX CXXFLAGS
export FC FCFLAGS
export F77 F77FLAGS
export AR
export LD LDFLAGS


# If requested, echo out our configured values
if [[ "$1" == "-v" ]]; then
    # Turn off command tracing so the output below doesn't get cluttered up
    if [[ "$-" == *x* ]]; then
        set +x
        restore_x_opt=1
    fi

    echo -e "\n-----  CONFIGURED BUILD ENVIRONMENT  -----"
    for var in BUILD_ARCH BUILD_OS \
        CPP CPPFLAGS CC CFLAGS CXX CXXFLAGS \
        FC FCFLAGS F77 F77FLAGS \
        AR LD LDFLAGS \
        CC_IS_GNU MAKE_JOBS;
    do
        printf '%-10s = %s\n' "${var}" "${!var}"
    done
    echo -e "-----  CONFIGURED BUILD ENVIRONMENT  -----\n"

    # Restore command tracing (if needed)
    if [[ ${restore_x_opt:-0} -eq 1 ]]; then
        unset restore_x_opt
        set -x
    fi
fi
