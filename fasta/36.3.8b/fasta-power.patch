--- /dev/null
+++ make/Makefile.ppc64.gnu
@@ -0,0 +1,85 @@
+# $Name:  $ - $Id: Makefile.pLinux 488 2011-01-21 17:38:53Z wrp $
+#
+# makefile for fasta3, fasta3_t.  Use makefile.pvm for pvcompxx.
+# this file works for DEC Alphas
+#
+# this file supports mmap()'ed databases in BLAST2 format use -DUSE_MMAP
+# for mmap()ed BLAST2 format.
+
+# the -DDEBUG option provides additional debugging information, particularly
+# with -D on the command line.
+
+# use -DBIG_LIB64 to generate and use 64-bit offsets in map_db .xin
+# files
+
+# for Tru64 4.0F, no "<inttypes.h>" 4.0G has inttypes.h
+
+CC ?= gcc
+CC += -DSW_ALTIVEC -DIS_BIG_ENDIAN
+#CC= gcc -maltivec -mvsx -m64
+#CC= cc -g3 -O -std1
+#CC= insure -g -DDEBUG
+#CC= cc -g -DDEBUG -std1
+
+#CC= gcc -g -Wall
+#
+# standard line for normal searching
+#CFLAGS += -mcpu=power8 -mtune=power8 -maltivec -mvsx -m64 -O3
+CFLAGS += -DUNIX -DTIMES -DBIGMEM -DMAX_WORKERS=96 -DSFCHAR="':'" -DTHR_EXIT=pthread_exit -DPROGRESS -DUSE_MMAP -DSAMP_STATS -DPGM_DOC -D_LARGE_FILES -DHAS_INTTYPES -D__pLinux__ -DBIG_LIB64
+#
+#(-DMYSQL_DB for mySQL databases)  (also requires change to Makefile35.common)
+
+# special options for SUPERFAMLIES
+#CFLAGS= -DM10_CONS -DUNIX -DTIMES -DHZ=60 -DBIGMEM -DSFCHAR="'|'" -DMAX_WORKERS=4 -DTHR_EXIT=pthread_exit -DPROGRESS -DSUPERFAMNUM -DIS_LITTLE_ENDIAN -DUSE_MMAP -DMAXBEST=200000
+ 
+LIB_M = -lm
+#LIB_M = -L/usr/local/lib/mysql -lmysqlclient -lm
+# for mySQL databases
+
+HFLAGS= -o
+NFLAGS= -o
+
+#for DEC Unix V4.0 
+#THR_SUBS = pthr_subs2
+#THR_LIBS = -lpthreads
+#THR_CC =
+
+#for Sun
+#THR_SUBS = uthr_subs
+#THR_LIBS = -lthread
+#THR_CC =
+#
+# for SGI with current pthreads
+#THR_SUBS = pthr_subs
+#THR_LIBS = -lpthreads
+#THR_CC = 
+#
+# for IBM with current pthreads
+#CC= xlc_r -v -g
+#THR_SUBS = ibm_pthr_subs
+#THR_LIBS = -lpthreads
+#THR_CC =
+
+
+# for IBM Linux with current pthreads
+THR_SUBS = pthr_subs2
+THR_LIBS = -lpthread
+
+BIN = ../bin
+XDIR = /seqprg/slib/bin
+
+# set up files for SSE2/Altivec acceleration
+#
+include ../make/Makefile.sse_alt
+
+# no acceleration
+#
+DROPGSW_O = $(DROPGSW_ALT_O)
+DROPLAL_O = $(DROPLAL_ALT_O)
+DROPGNW_O = $(DROPGNW_NA_O)
+DROPLNW_O = $(DROPLNW_NA_O)
+
+# renamed (fasta34)  programs
+#include ../make/Makefile36m.common_sql
+include ../make/Makefile36m.common
+
--- /dev/null
+++ make/Makefile.ppc64le.gnu
@@ -0,0 +1,85 @@
+# $Name:  $ - $Id: Makefile.pLinux 488 2011-01-21 17:38:53Z wrp $
+#
+# makefile for fasta3, fasta3_t.  Use makefile.pvm for pvcompxx.
+# this file works for DEC Alphas
+#
+# this file supports mmap()'ed databases in BLAST2 format use -DUSE_MMAP
+# for mmap()ed BLAST2 format.
+
+# the -DDEBUG option provides additional debugging information, particularly
+# with -D on the command line.
+
+# use -DBIG_LIB64 to generate and use 64-bit offsets in map_db .xin
+# files
+
+# for Tru64 4.0F, no "<inttypes.h>" 4.0G has inttypes.h
+
+CC ?= gcc
+CC += -DSW_VMX -DIS_LITTLE_ENDIAN -D__LITTLE_ENDIAN__
+#CC= gcc -maltivec -mvsx -m64
+#CC= cc -g3 -O -std1
+#CC= insure -g -DDEBUG
+#CC= cc -g -DDEBUG -std1
+
+#CC= gcc -g -Wall
+#
+# standard line for normal searching
+#CFLAGS += -mcpu=power8 -mtune=power8 -maltivec -mvsx -m64 -O3
+CFLAGS += -DUNIX -DTIMES -DBIGMEM -DMAX_WORKERS=96 -DSFCHAR="':'" -DTHR_EXIT=pthread_exit -DPROGRESS -DUSE_MMAP -DSAMP_STATS -DPGM_DOC -D_LARGE_FILES -DHAS_INTTYPES -D__pLinux__ -DBIG_LIB64
+#
+#(-DMYSQL_DB for mySQL databases)  (also requires change to Makefile35.common)
+
+# special options for SUPERFAMLIES
+#CFLAGS= -DM10_CONS -DUNIX -DTIMES -DHZ=60 -DBIGMEM -DSFCHAR="'|'" -DMAX_WORKERS=4 -DTHR_EXIT=pthread_exit -DPROGRESS -DSUPERFAMNUM -DIS_LITTLE_ENDIAN -DUSE_MMAP -DMAXBEST=200000
+ 
+LIB_M = -lm
+#LIB_M = -L/usr/local/lib/mysql -lmysqlclient -lm
+# for mySQL databases
+
+HFLAGS= -o
+NFLAGS= -o
+
+#for DEC Unix V4.0 
+#THR_SUBS = pthr_subs2
+#THR_LIBS = -lpthreads
+#THR_CC =
+
+#for Sun
+#THR_SUBS = uthr_subs
+#THR_LIBS = -lthread
+#THR_CC =
+#
+# for SGI with current pthreads
+#THR_SUBS = pthr_subs
+#THR_LIBS = -lpthreads
+#THR_CC = 
+#
+# for IBM with current pthreads
+#CC= xlc_r -v -g
+#THR_SUBS = ibm_pthr_subs
+#THR_LIBS = -lpthreads
+#THR_CC =
+
+
+# for IBM Linux with current pthreads
+THR_SUBS = pthr_subs2
+THR_LIBS = -lpthread
+
+BIN = ../bin
+XDIR = /seqprg/slib/bin
+
+# set up files for SSE2/Altivec acceleration
+#
+include ../make/Makefile.sse_alt
+
+# no acceleration
+#
+DROPGSW_O = $(DROPGSW_VMX_O)
+DROPLAL_O = $(DROPLAL_VMX_O)
+DROPGNW_O = $(DROPGNW_VMX_O)
+DROPLNW_O = $(DROPLNW_VMX_O)
+
+# renamed (fasta34)  programs
+#include ../make/Makefile36m.common_sql
+include ../make/Makefile36m.common
+
--- make/Makefile.sse_alt
+++ make/Makefile.sse_alt
@@ -5,19 +5,24 @@
 #
 DROPGSW_NA_O = init_sw.o dropgsw2.o lwm_align.o calcons_sw.o
 DROPGSW_SSE_O = init_sw_sse.o dropgsw2_sse.o smith_waterman_sse2.o lwm_align.o calcons_sw.o
+DROPGSW_VMX_O = init_sw_sse.o dropgsw2_sse.o smith_waterman_vmx.o lwm_align.o calcons_sw.o
 DROPGSW_ALT_O = init_sw_alt.o dropgsw2_alt.o smith_waterman_altivec.o lwm_align.o calcons_sw.o
 
 P_DROPNSW_NA_O = dropnsw.o lwm_align.o calcons_sw.o
 P_DROPGSW_NA_O = dropgsw2.o lwm_align.o calcons_sw.o
 P_DROPGSW_SSE_O = dropgsw2_sse.o smith_waterman_sse2.o lwm_align.o calcons_sw.o
+P_DROPGSW_VMX_O = dropgsw2_sse.o smith_waterman_vmx.o lwm_align.o calcons_sw.o
 P_DROPGSW_ALT_O = dropgsw2_alt.o smith_waterman_altivec.o lwm_align.o calcons_sw.o
 
 DROPLAL_NA_O = droplal2.o lsim4.o calcons_la.o
 DROPLAL_SSE_O = droplal2_sse.o smith_waterman_sse2.o lsim4.o calcons_la.o
+DROPLAL_VMX_O = droplal2_sse.o smith_waterman_vmx.o lsim4.o calcons_la.o
 DROPLAL_ALT_O = droplal2_alt.o smith_waterman_altivec.o lsim4.o calcons_la.o
 
 DROPGNW_NA_O = init_gnw.o dropgnw.o gwm_align.o calcons_sw.o
 DROPGNW_SSE_O = init_gnw_sse.o dropgnw_sse.o global_sse2.o gwm_align.o calcons_sw.o
+DROPGNW_VMX_O = init_gnw_sse.o dropgnw_sse.o global_vmx.o gwm_align.o calcons_sw.o
 
 DROPLNW_NA_O = init_lnw.o droplnw.o gwm_align.o calcons_sw.o
 DROPLNW_SSE_O = init_lnw_sse.o droplnw_sse.o glocal_sse2.o gwm_align.o calcons_sw.o
+DROPLNW_VMX_O = init_lnw_sse.o droplnw_sse.o glocal_vmx.o gwm_align.o calcons_sw.o
--- src/dropgsw2.c
+++ src/dropgsw2.c
@@ -68,6 +68,9 @@ static char *verstr="7.2 Nov 2010";
 #ifdef SW_SSE2
 #include "smith_waterman_sse2.h"
 #endif
+#ifdef SW_VMX
+#include "smith_waterman_vmx.h"
+#endif
 
 struct swstr {int H, E;};
 
@@ -141,7 +144,7 @@ init_work (unsigned char *aa0, int n0,
   struct swstr *ss;
   int nsq;
 
-#if defined(SW_ALTIVEC) || defined(SW_SSE2)
+#if defined(SW_ALTIVEC) || defined(SW_SSE2) || defined (SW_VMX)
   int l, data, bias;
   unsigned char *  pc;
   unsigned short * ps;
@@ -446,7 +449,7 @@ init_work (unsigned char *aa0, int n0,
        
 #endif /* SW_ALTIVEC */
 
-#if defined(SW_SSE2)
+#if defined(SW_SSE2) || defined(SW_VMX)
    /* First we allocate memory for the workspace - i.e. two rows for H and
     * one row for F.  We also need enough space to hold a temporary
     * scoring profile which will be query_length * 16 (sse2 word length).
@@ -639,7 +642,7 @@ void close_work (const unsigned char *aa0, int n0,
     free(f_str->pam2p[1][0]);
     free(f_str->pam2p[1]);
 
-#if defined(SW_ALTIVEC) || defined(SW_SSE2)
+#if defined(SW_ALTIVEC) || defined(SW_SSE2) || defined(SW_VMX)
     free(f_str->workspace_memory);
     free(f_str->word_score_memory);
     free(f_str->byte_score_memory);
@@ -662,10 +665,10 @@ void    get_param (const struct pstruct *ppst,
 #if defined(SW_ALTIVEC)
   strncpy(pg_str,"Smith-Waterman (Altivec/VMX, Erik Lindahl 2004)",sizeof(pg_str));
 #endif
-#if defined(SW_SSE2)
+#if defined(SW_SSE2) || defined(SW_VMX)
   strncpy(pg_str,"Smith-Waterman (SSE2, Michael Farrar 2006)",sizeof(pg_str));
 #endif
-#if !defined(SW_ALTIVEC) && !defined(SW_SSE2)
+#if !defined(SW_ALTIVEC) && !defined(SW_SSE2) && !defined(SW_VMX)
   strncpy(pg_str,"Smith-Waterman (PGopt)",sizeof(pg_str));
 #endif
 
@@ -782,11 +785,15 @@ void do_work (const unsigned char *aa0, int n0,
 
 #endif /* not Altivec */
 
-#if defined(SW_SSE2)
+#if defined(SW_SSE2) || defined(SW_VMX)
 
   if(f_str->try_8bit)
   {
+#if defined(SW_VMX)
+      score = smith_waterman_vmx_byte(aa0,
+#else
       score = smith_waterman_sse2_byte(aa0,
+#endif
                                        f_str->byte_score,
                                        n0,
                                        aa1,
@@ -805,7 +812,12 @@ void do_work (const unsigned char *aa0, int n0,
       if(score>=255)
       {
           /* Overflow, so we have to redo it in 16 bits. */
+#if defined(SW_VMX)
+          score = smith_waterman_vmx_word(aa0,
+#else
           score = smith_waterman_sse2_word(aa0,
+#endif
+
                                            f_str->word_score,
                                            n0,
                                            aa1,
@@ -831,7 +843,12 @@ void do_work (const unsigned char *aa0, int n0,
   else
   { 
       /* Just use the 16-bit altivec version directly */
+#if defined(SW_VMX)
+      score = smith_waterman_vmx_word(aa0,
+#else
       score = smith_waterman_sse2_word(aa0,
+#endif
+
                                        f_str->word_score,
                                        n0,
                                        aa1,
@@ -846,7 +863,7 @@ void do_work (const unsigned char *aa0, int n0,
   }      
 #endif
 
-#if !defined(SW_ALTIVEC) && !defined(SW_SSE2)
+#if !defined(SW_ALTIVEC) && !defined(SW_SSE2) && !defined(SW_VMX)
 
   score = FLOCAL_ALIGN(aa0,aa1,n0,n1,0,0,
                        NULL,
--- src/dropgsw2.h
+++ src/dropgsw2.h
@@ -15,7 +15,7 @@ struct f_struct {
   double e_cut;
   int show_ident;
   int max_repeat;
-#if defined(SW_ALTIVEC) || defined(SW_SSE2)
+#if defined(SW_ALTIVEC) || defined(SW_SSE2) || defined (SW_VMX)
   unsigned char      bias;
   unsigned char      ceiling;
   unsigned short *   word_score;
--- src/initfa.c
+++ src/initfa.c
@@ -1854,7 +1854,7 @@ last_init (struct mngmsg *m_msg, struct pstruct *ppst)
     else { m_msg->thr_fact = 4;}
   }
   else {
-#if !defined(SW_ALTIVEC) && !defined(SW_SSE2)
+#if !defined(SW_ALTIVEC) && !defined(SW_SSE2) && !defined(SW_VMX)
     m_msg->thr_fact = 1;	/* unvectorized SSEARCH  */
 #else
     m_msg->thr_fact = 8;	/* vectorized SSEARCH */
--- src/smith_waterman_altivec.c
+++ src/smith_waterman_altivec.c
@@ -18,7 +18,7 @@
 #include "dropgsw2.h"
 
 #ifdef SW_ALTIVEC
-
+#include <altivec.h>
 int
 smith_waterman_altivec_word(unsigned char *     query_sequence,
                             unsigned short *    query_profile_word,
@@ -46,10 +46,10 @@ smith_waterman_altivec_word(unsigned char *     query_sequence,
     vector unsigned short   v_score_q2;
     vector unsigned short   v_score_q3;
     vector unsigned short   v_score_load; 
-    vector unsigned char    queue1_to_score  = (vector unsigned char)(16,17,2,3,4,5,6,7,8,9,10,11,12,13,14,15);
-    vector unsigned char    queue2_to_queue1 = (vector unsigned char)(0,1,18,19,4,5,6,7,8,9,10,11,12,13,14,15);
-    vector unsigned char    queue3_to_queue2 = (vector unsigned char)(16,16,16,16,16,21,16,0,16,1,16,2,16,3,16,4);
-    vector unsigned char    queue3_with_load = (vector unsigned char)(23,5,6,7,8,25,9,10,11,27,12,13,29,14,31,16);
+    vector unsigned char    queue1_to_score  = (vector unsigned char){16,17,2,3,4,5,6,7,8,9,10,11,12,13,14,15};
+    vector unsigned char    queue2_to_queue1 = (vector unsigned char){0,1,18,19,4,5,6,7,8,9,10,11,12,13,14,15};
+    vector unsigned char    queue3_to_queue2 = (vector unsigned char){16,16,16,16,16,21,16,0,16,1,16,2,16,3,16,4};
+    vector unsigned char    queue3_with_load = (vector unsigned char){23,5,6,7,8,25,9,10,11,27,12,13,29,14,31,16};
         
     /* Load the bias to all elements of a constant */
     v_bias           = vec_lde(0,&bias);
@@ -1091,13 +1091,13 @@ smith_waterman_altivec_byte(unsigned char *     query_sequence,
     vector unsigned char    v_score_load2;  
     vector unsigned char    v_zero;  
 
-    vector unsigned char    queue1_to_score  = (vector unsigned char)(16,1,2,3,4,5,6,7,24,9,10,11,12,13,14,15);
-    vector unsigned char    queue2_to_queue1 = (vector unsigned char)(16,17,2,3,4,5,6,7,24,25,10,11,12,13,14,15);
-    vector unsigned char    queue3_to_queue2 = (vector unsigned char)(16,17,18,3,4,5,6,7,24,25,26,11,12,13,14,15);
-    vector unsigned char    queue4_to_queue3 = (vector unsigned char)(16,17,18,19,4,5,6,7,24,25,26,27,12,13,14,15);
-    vector unsigned char    queue5_to_queue4 = (vector unsigned char)(16,17,18,19,20,2,3,4,24,25,26,27,28,10,11,12);
-    vector unsigned char    queue5_with_load = (vector unsigned char)(19,20,21,5,6,22,7,23,27,28,29,13,14,30,15,31);
-    vector unsigned char    merge_score_load = (vector unsigned char)(0,1,2,3,4,5,6,7,24,25,26,27,28,29,30,31);
+    vector unsigned char    queue1_to_score  = (vector unsigned char){16,1,2,3,4,5,6,7,24,9,10,11,12,13,14,15};
+    vector unsigned char    queue2_to_queue1 = (vector unsigned char){16,17,2,3,4,5,6,7,24,25,10,11,12,13,14,15};
+    vector unsigned char    queue3_to_queue2 = (vector unsigned char){16,17,18,3,4,5,6,7,24,25,26,11,12,13,14,15};
+    vector unsigned char    queue4_to_queue3 = (vector unsigned char){16,17,18,19,4,5,6,7,24,25,26,27,12,13,14,15};
+    vector unsigned char    queue5_to_queue4 = (vector unsigned char){16,17,18,19,20,2,3,4,24,25,26,27,28,10,11,12};
+    vector unsigned char    queue5_with_load = (vector unsigned char){19,20,21,5,6,22,7,23,27,28,29,13,14,30,15,31};
+    vector unsigned char    merge_score_load = (vector unsigned char){0,1,2,3,4,5,6,7,24,25,26,27,28,29,30,31};
 
     v_zero           = vec_splat_u8(0);
         
--- /dev/null
+++ src/smith_waterman_vmx.c
@@ -0,0 +1,432 @@
+/******************************************************************
+  Copyright 2006 by Michael Farrar.  All rights reserved.
+  This program may not be sold or incorporated into a commercial product,
+  in whole or in part, without written consent of Michael Farrar.  For 
+  further information regarding permission for use or reproduction, please 
+  contact: Michael Farrar at farrar.michael@gmail.com.
+*******************************************************************/
+
+/*
+  Written by Michael Farrar, 2006.
+  Please send bug reports and/or suggestions to farrar.michael@gmail.com.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "defs.h"
+#include "param.h"
+#include "dropgsw2.h"
+#include "smith_waterman_vmx.h"
+
+#ifdef __SUNPRO_C
+#include <sunmedia_intrin.h>
+#else
+#include "vec128int.h"
+#endif
+
+#ifdef SW_VMX
+
+int
+smith_waterman_vmx_word(const unsigned char *     query_sequence,
+                         unsigned short *    query_profile_word,
+                         const int                 query_length,
+                         const unsigned char *     db_sequence,
+                         const int                 db_length,
+                         unsigned short      gap_open,
+                         unsigned short      gap_extend,
+                         struct f_struct *   f_str)
+{
+    int     i, j, k;
+    short   score;
+
+    int     cmp;
+    int     iter = (query_length + 7) / 8;
+    
+
+    __m128i *p;
+    __m128i *workspace = (__m128i *) f_str->workspace;
+
+    __m128i E, F, H;
+
+    __m128i v_maxscore;
+    __m128i v_gapopen;
+    __m128i v_gapextend;
+
+    __m128i v_min;
+    __m128i v_minimums;
+    __m128i v_temp;
+
+    __m128i *pHLoad, *pHStore;
+    __m128i *pE;
+
+    __m128i *pScore;
+
+    /* Load gap opening penalty to all elements of a constant */
+    v_gapopen = vec_zero1q();	/* Apple Devel */
+    v_gapopen = vec_insert8sh (v_gapopen, gap_open, 0);
+    v_gapopen = vec_permutelower4sh (v_gapopen, 0);
+    v_gapopen = vec_permute4sw (v_gapopen, 0);
+
+    /* Load gap extension penalty to all elements of a constant */
+    v_gapextend = vec_zero1q();	/* Apple Devel */
+    v_gapextend = vec_insert8sh (v_gapextend, gap_extend, 0);
+    v_gapextend = vec_permutelower4sh (v_gapextend, 0);
+    v_gapextend = vec_permute4sw (v_gapextend, 0);
+
+    /* load v_maxscore with the zeros.  since we are using signed */
+    /*  math, we will bias the maxscore to -32768 so we have the */
+    /*  full range of the short. */
+    v_maxscore = vec_zero1q();	/* Apple Devel */
+    v_maxscore = vec_compareeq8sh (v_maxscore, v_maxscore);
+    v_maxscore = vec_shiftleftimmediate8sh (v_maxscore, 15);
+
+    v_minimums = vec_permute4sw (v_maxscore, 0);
+
+    v_min = vec_permute4sw (v_maxscore, 0);
+    v_min = vec_shiftrightbytes1q (v_min, 14);
+
+    /* Zero out the storage vector */
+    k = 2 * iter;
+
+    p = workspace;
+    for (i = 0; i < k; i++)
+    {
+        vec_store1q (p++, v_maxscore);
+    }
+
+    pE = workspace;
+    pHStore = pE + iter;
+    pHLoad = pHStore + iter;
+
+    for (i = 0; i < db_length; ++i)
+    {
+        /* fetch first data asap. */
+        pScore = (__m128i *) query_profile_word + db_sequence[i] * iter;
+
+        /* bias all elements in F to -32768 */
+        F = vec_zero1q();	/* Apple Devel */
+        F = vec_compareeq8sh (F, F);
+        F = vec_shiftleftimmediate8sh (F, 15);
+
+        /* load the next h value */
+        H = vec_load1q (pHStore + iter - 1);
+        H = vec_shiftleftbytes1q (H, 2);
+        H = vec_bitor1q (H, v_min);
+
+        p = pHLoad;
+        pHLoad = pHStore;
+        pHStore = p;
+
+        for (j = 0; j < iter; j++)
+        {
+            /* load E values */
+            E = vec_load1q (pE + j);
+
+            /* add score to H */
+            H = vec_addsaturating8sh (H, *pScore++);
+
+            /* Update highest score encountered this far */
+            v_maxscore = vec_max8sh (v_maxscore, H);
+
+            /* get max from H, E and F */
+            H = vec_max8sh (H, E);
+            H = vec_max8sh (H, F);
+
+            /* save H values */
+            vec_store1q (pHStore + j, H);
+
+            /* subtract the gap open penalty from H */
+            H = vec_subtractsaturating8sh (H, v_gapopen);
+
+            /* update E value */
+            E = vec_subtractsaturating8sh (E, v_gapextend);
+            E = vec_max8sh (E, H);
+
+            /* update F value */
+            F = vec_subtractsaturating8sh (F, v_gapextend);
+            F = vec_max8sh (F, H);
+
+            /* save E values */
+            vec_store1q (pE + j, E);
+
+            /* load the next h value */
+            H = vec_load1q (pHLoad + j);
+        }
+
+        /* reset pointers to the start of the saved data */
+        j = 0;
+        H = vec_load1q (pHStore + j);
+
+        /*  the computed F value is for the given column.  since */
+        /*  we are at the end, we need to shift the F value over */
+        /*  to the next column. */
+        F = vec_shiftleftbytes1q (F, 2);
+        F = vec_bitor1q (F, v_min);
+        v_temp = vec_subtractsaturating8sh (H, v_gapopen);
+        v_temp = vec_comparegt8sh (F, v_temp);
+        cmp  = vec_extractupperbit16sb (v_temp);
+
+        while (cmp != 0x0000) 
+        {
+            E = vec_load1q (pE + j);
+
+            H = vec_max8sh (H, F);
+
+            /* save H values */
+            vec_store1q (pHStore + j, H);
+
+            /* update E in case the new H value would change it */
+            H = vec_subtractsaturating8sh (H, v_gapopen);
+            E = vec_max8sh (E, H);
+            vec_store1q (pE + j, E);
+
+            /* update F value */
+            F = vec_subtractsaturating8sh (F, v_gapextend);
+
+            j++;
+            if (j >= iter)
+            {
+                j = 0;
+                F = vec_shiftleftbytes1q (F, 2);
+                F = vec_bitor1q (F, v_min);
+            }
+            H = vec_load1q (pHStore + j);
+
+            v_temp = vec_subtractsaturating8sh (H, v_gapopen);
+            v_temp = vec_comparegt8sh (F, v_temp);
+            cmp  = vec_extractupperbit16sb (v_temp);
+        }
+    }
+
+    /* find largest score in the v_maxscore vector */
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 8);
+    v_maxscore = vec_max8sh (v_maxscore, v_temp);
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 4);
+    v_maxscore = vec_max8sh (v_maxscore, v_temp);
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 2);
+    v_maxscore = vec_max8sh (v_maxscore, v_temp);
+
+    /* extract the largest score */
+    score = vec_extract8sh (v_maxscore, 0);
+
+    /* return largest score biased by 32768 */
+
+    /* fix for Mac OSX clang 4.1 */ 
+    /*
+#ifdef __clang__
+    if (score < 0) score += 32768;
+    return score;
+#else
+    */
+    return score + 32768;
+    /* #endif */
+}
+
+int
+smith_waterman_vmx_byte(const unsigned char *     query_sequence,
+                         unsigned char *     query_profile_byte,
+                         const int                 query_length,
+                         const unsigned char *     db_sequence,
+                         const int                 db_length,
+                         unsigned char       bias,
+                         unsigned char       gap_open,
+                         unsigned char       gap_extend,
+                         struct f_struct *   f_str)
+{
+    int     i, j, k;
+    int     score;
+
+    int     dup;
+    int     cmp;
+    int     iter = (query_length + 15) / 16;
+    
+    __m128i *p;
+    __m128i *workspace = (__m128i *) f_str->workspace;
+
+    __m128i E, F, H;
+
+    __m128i v_maxscore;
+    __m128i v_bias;
+    __m128i v_gapopen;
+    __m128i v_gapextend;
+
+    __m128i v_temp;
+    __m128i v_zero;
+
+    __m128i *pHLoad, *pHStore;
+    __m128i *pE;
+
+    __m128i *pScore;
+
+    /* Load the bias to all elements of a constant */
+    dup    = ((short) bias << 8) | bias;
+    v_bias = vec_zero1q();
+    v_bias = vec_insert8sh (v_bias, dup, 0);
+    v_bias = vec_permutelower4sh (v_bias, 0);
+    v_bias = vec_permute4sw (v_bias, 0);
+
+    /* Load gap opening penalty to all elements of a constant */
+    dup  = ((short) gap_open << 8) | gap_open;
+    v_gapopen = vec_zero1q();
+    v_gapopen = vec_insert8sh (v_gapopen, dup, 0);
+    v_gapopen = vec_permutelower4sh (v_gapopen, 0);
+    v_gapopen = vec_permute4sw (v_gapopen, 0);
+
+    /* Load gap extension penalty to all elements of a constant */
+    dup  = ((short) gap_extend << 8) | gap_extend;
+    v_gapextend = vec_zero1q();
+    v_gapextend = vec_insert8sh (v_gapextend, dup, 0);
+    v_gapextend = vec_permutelower4sh (v_gapextend, 0);
+    v_gapextend = vec_permute4sw (v_gapextend, 0);
+
+    /* initialize the max score */
+    /*     v_maxscore = vec_bitxor1q (v_maxscore, v_maxscore);  - Apple Devel*/
+    v_maxscore = vec_zero1q();	/* Apple Devel */
+
+    /* create a constant of all zeros for comparison */
+    /* v_zero = vec_bitxor1q (v_zero, v_zero);   - Apple Devel */
+    v_zero = vec_zero1q();	/* Apple Devel */
+
+    /* Zero out the storage vector */
+    k = iter * 2;
+
+    p = workspace;
+    for (i = 0; i < k; i++)
+    {
+        vec_store1q (p++, v_maxscore);
+    }
+
+    pE = workspace;
+    pHStore = pE + iter;
+    pHLoad = pHStore + iter;
+
+    for (i = 0; i < db_length; ++i)
+    {
+        /* fetch first data asap. */
+        pScore = (__m128i *) query_profile_byte + db_sequence[i] * iter;
+
+        /* zero out F value. */
+        /* F = vec_bitxor1q (F, F);  -Apple Devel */
+        F = vec_zero1q();	/* Apple Devel */
+
+        /* load the next h value */
+        H = vec_load1q (pHStore + iter - 1);
+        H = vec_shiftleftbytes1q (H, 1);
+
+        p = pHLoad;
+        pHLoad = pHStore;
+        pHStore = p;
+
+        for (j = 0; j < iter; j++)
+        {
+            /* load values E. */
+            E = vec_load1q (pE + j);
+
+            /* add score to H */
+            H = vec_addsaturating16ub (H, *pScore++);
+            H = vec_subtractsaturating16ub (H, v_bias);
+
+            /* Update highest score encountered this far */
+            v_maxscore = vec_max16ub (v_maxscore, H);
+
+            /* get max from H, E and F */
+            H = vec_max16ub (H, E);
+            H = vec_max16ub (H, F);
+
+            /* save H values */
+            vec_store1q (pHStore + j, H);
+
+            /* subtract the gap open penalty from H */
+            H = vec_subtractsaturating16ub (H, v_gapopen);
+
+            /* update E value */
+            E = vec_subtractsaturating16ub (E, v_gapextend);
+            E = vec_max16ub (E, H);
+
+            /* update F value */
+            F = vec_subtractsaturating16ub (F, v_gapextend);
+            F = vec_max16ub (F, H);
+
+            /* save E values */
+            vec_store1q (pE + j, E);
+
+            /* load the next h value */
+            H = vec_load1q (pHLoad + j);
+        }
+
+        /* reset pointers to the start of the saved data */
+        j = 0;
+        H = vec_load1q (pHStore + j);
+
+        /*  the computed F value is for the given column.  since */
+        /*  we are at the end, we need to shift the F value over */
+        /*  to the next column. */
+        F = vec_shiftleftbytes1q (F, 1);
+        v_temp = vec_subtractsaturating16ub (H, v_gapopen);
+        v_temp = vec_subtractsaturating16ub (F, v_temp);
+        v_temp = vec_compareeq16sb (v_temp, v_zero);
+        cmp  = vec_extractupperbit16sb (v_temp);
+
+        while (cmp != 0xffff) 
+        {
+            E = vec_load1q (pE + j);
+
+            H = vec_max16ub (H, F);
+
+            /* save H values */
+            vec_store1q (pHStore + j, H);
+
+            /* update E in case the new H value would change it */
+            H = vec_subtractsaturating16ub (H, v_gapopen);
+            E = vec_max16ub (E, H);
+            vec_store1q (pE + j, E);
+
+            /* update F value */
+            F = vec_subtractsaturating16ub (F, v_gapextend);
+
+            j++;
+            if (j >= iter)
+            {
+                j = 0;
+                F = vec_shiftleftbytes1q (F, 1);
+            }
+            H = vec_load1q (pHStore + j);
+
+            v_temp = vec_subtractsaturating16ub (H, v_gapopen);
+            v_temp = vec_subtractsaturating16ub (F, v_temp);
+            v_temp = vec_compareeq16sb (v_temp, v_zero);
+            cmp  = vec_extractupperbit16sb (v_temp);
+        }
+    }
+
+    /* find largest score in the v_maxscore vector */
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 8);
+    v_maxscore = vec_max16ub (v_maxscore, v_temp);
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 4);
+    v_maxscore = vec_max16ub (v_maxscore, v_temp);
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 2);
+    v_maxscore = vec_max16ub (v_maxscore, v_temp);
+    v_temp = vec_shiftrightbytes1q (v_maxscore, 1);
+    v_maxscore = vec_max16ub (v_maxscore, v_temp);
+
+    /* store in temporary variable */
+    score = vec_extract8sh (v_maxscore, 0);
+    score = score & 0x00ff;
+
+    /*  check if we might have overflowed */
+    if (score + bias >= 255)
+    {
+        score = 255;
+    }
+
+    /* return largest score */
+    return score;
+}
+#else
+
+/* No SSE2 support. Avoid compiler complaints about empty object */
+
+int sw_dummy;
+
+#endif
--- /dev/null
+++ src/smith_waterman_vmx.h
@@ -0,0 +1,43 @@
+
+/* $Id: smith_waterman_sse2.h 625 2011-03-23 17:21:38Z wrp $ */
+/* $Revision: 625 $  */
+
+/******************************************************************
+  Copyright 2006 by Michael Farrar.  All rights reserved.
+  This program may not be sold or incorporated into a commercial product,
+  in whole or in part, without written consent of Michael Farrar.  For 
+  further information regarding permission for use or reproduction, please 
+  contact: Michael Farrar at farrar.michael@gmail.com.
+*******************************************************************/
+
+/*
+  Written by Michael Farrar, 2006.
+  Please send bug reports and/or suggestions to farrar.michael@gmail.com.
+*/
+
+#ifndef SMITH_WATERMAN_VMX_H
+#define SMITH_WATERMAN_VMX_H
+
+int
+smith_waterman_vmx_word(const unsigned char *     query_sequence,
+                         unsigned short *    query_profile_word,
+                         const int                 query_length,
+                         const unsigned char *     db_sequence,
+                         const int                 db_length,
+                         unsigned short      gap_open,
+                         unsigned short      gap_extend,
+                         struct f_struct *   f_str);
+
+
+int
+smith_waterman_vmx_byte(const unsigned char *     query_sequence,
+                         unsigned char *     query_profile_byte,
+                         const int                 query_length,
+                         const unsigned char *     db_sequence,
+                         const int                 db_length,
+                         unsigned char       bias,
+                         unsigned char       gap_open,
+                         unsigned char       gap_extend,
+                         struct f_struct *   f_str);
+
+#endif /* SMITH_WATERMAN_VMX_H */
--- /dev/null
+++ src/global_vmx.c
@@ -0,0 +1,547 @@
+/******************************************************************
+  Copyright 2010 by Michael Farrar.  All rights reserved.
+  This program may not be sold or incorporated into a commercial product,
+  in whole or in part, without written consent of Michael Farrar.  For 
+  further information regarding permission for use or reproduction, please 
+  contact: Michael Farrar at farrar.michael@gmail.com.
+*******************************************************************/
+
+/*
+  Written by Michael Farrar, 2010.
+  Please send bug reports and/or suggestions to farrar.michael@gmail.com.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "defs.h"
+#include "param.h"
+#include "dropgsw2.h"
+#include "global_sse2.h"
+
+#ifdef __SUNPRO_C
+#include <sunmedia_intrin.h>
+#else
+#include "vec128int.h"
+#endif
+
+#ifdef SW_VMX
+
+static inline __m128i
+max_epu16(__m128i a, __m128i b)
+{
+  a = vec_subtractsaturating8uh (a, b);
+  b = vec_addsaturating8uh (b, a);
+  return b;
+}
+
+
+int
+global_sse2_word(int                  queryLength,
+                 unsigned short      *profile,
+                 const unsigned char *dbSeq,
+                 int                  dbLength,
+                 unsigned short       gapOpen,
+                 unsigned short       gapExtend,
+                 unsigned short       ceiling,
+                 struct f_struct     *f_str)
+{
+  int     i, j;
+
+  int     score;
+  int     scale;
+  int     temp;
+  int     distance;
+
+  int     offset;
+  int     position;
+
+  int     cmp;
+  int     iter;
+    
+  __m128i *pvH;
+  __m128i *pvE;
+
+  __m128i vE, vF, vH;
+  __m128i vHNext;
+  __m128i vFPrev;
+
+  __m128i vGapOpen;
+  __m128i vGapExtend;
+  __m128i vCeiling;
+
+  __m128i vScale;
+  __m128i vScaleAmt;
+  __m128i vScaleTmp;
+
+  __m128i vTemp;
+  __m128i vNull;
+
+  __m128i *pvScore;
+
+  scale = 0;
+  iter = (queryLength + 7) / 8;
+  offset = (queryLength - 1) % iter;
+  position = 7 - (queryLength - 1) / iter;
+
+  pvH = (__m128i *)f_str->workspace;
+  pvE = pvH + iter;
+
+  /* Load gap opening penalty to all elements of a constant */
+  vGapOpen = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapOpen = vec_insert8sh (vGapOpen, gapOpen, 0);
+  vGapOpen = vec_permutelower4sh (vGapOpen, 0);
+  vGapOpen = vec_permute4sw (vGapOpen, 0);
+
+  /* Load gap extension penalty to all elements of a constant */
+  vGapExtend = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapExtend = vec_insert8sh (vGapExtend, gapExtend, 0);
+  vGapExtend = vec_permutelower4sh (vGapExtend, 0);
+  vGapExtend = vec_permute4sw (vGapExtend, 0);
+
+  /* Generate the ceiling before scaling */
+  vTemp = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vTemp = vec_insert8sh (vTemp, ceiling, 0);
+  vTemp = vec_permutelower4sh (vTemp, 0);
+  vTemp = vec_permute4sw (vTemp, 0);
+  vCeiling = vec_compareeq8sh (vTemp, vTemp);
+  vCeiling = vec_shiftrightimmediate8sh (vCeiling, 1);
+  vCeiling = vec_subtractsaturating8sh (vCeiling, vTemp);
+  vCeiling = vec_subtractsaturating8sh (vCeiling, vGapOpen);
+
+  vNull = vec_compareeq8sh (vTemp, vTemp);
+  vNull = vec_shiftleftimmediate8sh (vNull, 15);
+  vScaleAmt = vec_bitxor1q (vNull, vNull);
+
+  /* Zero out the storage vector */
+  vTemp = vec_addsaturating8sh (vNull, vGapOpen);
+  for (i = 0; i < iter; i++) {
+    vec_store1q (pvH + i, vTemp);
+    vec_store1q (pvE + i, vNull);
+  }
+
+  /* initialize F */
+  vF = vNull;
+  vFPrev = vNull;
+
+  /* load and scale H for the next round */
+  vTemp = vec_shiftrightbytes1q (vGapOpen, 14);
+  vH = vec_load1q (pvH + iter - 1);
+  vH = vec_addsaturating8sh (vH, vTemp);
+
+  for (i = 0; i < dbLength; ++i) {
+    /* fetch first data asap. */
+    pvScore = (__m128i *) profile + dbSeq[i] * iter;
+
+    vF = vNull;
+
+    vH = vec_max8sh (vH, vFPrev);
+    for (j = 0; j < iter; j++) {
+      /* correct H from the previous columns F */
+      vHNext = vec_load1q (pvH + j);
+      vHNext = vec_max8sh (vHNext, vFPrev);
+
+      /* load and correct E value */
+      vE = vec_load1q (pvE + j);
+      vTemp = vec_subtractsaturating8sh (vHNext, vGapOpen);
+      vE = vec_max8sh (vE, vTemp);
+      vec_store1q (pvE + j, vE);
+
+      /* add score to vH */
+      vH = vec_addsaturating8sh (vH, *pvScore++);
+
+      /* get max from vH, vE and vF */
+      vH = vec_max8sh (vH, vE);
+      vH = vec_max8sh (vH, vF);
+      vec_store1q (pvH + j, vH);
+
+      /* update vF value */
+      vH = vec_subtractsaturating8sh (vH, vGapOpen);
+      vF = vec_max8sh (vF, vH);
+
+      /* load the next h values */
+      vH = vHNext;
+    }
+
+    /* check if we need to scale before the next round */
+    vTemp = vec_comparegt8sh (vF, vCeiling);
+    cmp  = vec_extractupperbit16sb (vTemp);
+
+    /* broadcast F values */
+    vF = vec_bitxor1q (vF, vNull);
+
+    vTemp  = vec_shiftleftbytes1q (vF, 2);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleAmt);
+    vF = max_epu16 (vF, vTemp);
+
+    vTemp  = vec_shiftleftbytes1q (vF, 4);
+    vScaleTmp = vec_shiftleftbytes1q (vScaleAmt, 2);
+    vScaleTmp = vec_addsaturating8uh (vScaleTmp, vScaleAmt);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleTmp);
+    vF = max_epu16 (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 4);
+    vScaleTmp = vec_addsaturating8uh (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 8);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleTmp);
+    vF = max_epu16 (vF, vTemp);
+
+    /* scale if necessary */
+    if (cmp != 0x0000) {
+      __m128i vScale1;
+      __m128i vScale2;
+
+      vScale = vec_shiftleftbytes1q (vF, 2);
+      vScale = vec_subtractsaturating8uh (vScale, vGapOpen);
+      vScale = vec_subtractsaturating8uh (vScale, vScaleAmt);
+
+      vTemp = vec_shiftleftbytes1q (vScale, 2);
+      vTemp = vec_subtractsaturating8uh (vScale, vTemp);
+      vScaleAmt = vec_addsaturating8uh (vScaleAmt, vTemp);
+      vTemp = vec_shiftleftbytes1q (vScale, 2);
+      vTemp = vec_subtractsaturating8uh (vTemp, vScale);
+      vScaleAmt = vec_subtractsaturating8uh (vScaleAmt, vTemp);
+
+      /* rescale the previous F */
+      vF = vec_subtractsaturating8uh (vF, vScale);
+
+      /* check if we can continue in signed 16-bits */
+      vTemp = vec_bitxor1q (vF, vNull);
+      vTemp = vec_comparegt8sh (vTemp, vCeiling);
+      cmp  = vec_extractupperbit16sb (vTemp);
+      if (cmp != 0x0000) {
+        return OVERFLOW_SCORE;
+      }
+
+      vTemp   = vec_addsaturating8sh (vCeiling, vCeiling);
+      vScale1 = vec_subtractsaturating8uh (vScale, vTemp);
+      vScale2 = vec_subtractsaturating8uh (vScale, vScale1);
+
+      /* scale all the vectors */
+      for (j = 0; j < iter; j++) {
+        /* load H and E */
+        vH = vec_load1q (pvH + j);
+        vE = vec_load1q (pvE + j);
+
+        /* get max from vH, vE and vF */
+        vH = vec_subtractsaturating8sh (vH, vScale1);
+        vH = vec_subtractsaturating8sh (vH, vScale2);
+        vE = vec_subtractsaturating8sh (vE, vScale1);
+        vE = vec_subtractsaturating8sh (vE, vScale2);
+
+        /* save the H and E */
+        vec_store1q (pvH + j, vH);
+        vec_store1q (pvE + j, vE);
+      }
+
+      vScale = vScaleAmt;
+      for (j = 0; j < position; ++j) {
+        vScale = vec_shiftleftbytes1q (vScale, 2);
+      }
+
+      /* calculate the final scaling amount */
+      vTemp   = vec_bitxor1q (vTemp, vTemp);
+      vScale1 = vec_unpacklow44sh (vScale, vTemp);
+      vScale2 = vec_unpackhigh44sh (vScale, vTemp);
+      vScale  = vec_add4sw (vScale1, vScale2);
+      vTemp = vec_shiftrightbytes1q (vScale, 8);
+      vScale = vec_add4sw (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 4);
+      vScale = vec_add4sw (vScale, vTemp);
+      scale = (int) (unsigned short) vec_extract8sh (vScale, 0);
+      temp  = (int) (unsigned short) vec_extract8sh (vScale, 1);
+      scale = scale + (temp << 16);
+    }
+
+    /* scale the F value for the next round */
+    vFPrev = vec_shiftleftbytes1q (vF, 2);
+    vFPrev = vec_subtractsaturating8uh (vFPrev, vScaleAmt);
+    vFPrev = vec_bitxor1q (vFPrev, vNull);
+
+    /* load and scale H for the next round */
+    vH = vec_load1q (pvH + iter - 1);
+    vH = vec_bitxor1q (vH, vNull);
+    vH = vec_shiftleftbytes1q (vH, 2);
+    vH = vec_subtractsaturating8uh (vH, vScaleAmt);
+    vH = vec_insert8sh (vH, gapOpen, 0);
+    vH = vec_bitxor1q (vH, vNull);
+  }
+
+  vH = vec_load1q (pvH + offset);
+  vH = vec_max8sh (vH, vFPrev);
+  for (j = 0; j < position; ++j) {
+    vH = vec_shiftleftbytes1q (vH, 2);
+  }
+  score = (int) (signed short) vec_extract8sh (vH, 7);
+  score = score + SHORT_BIAS;
+
+  /* return largest score */
+  distance = (queryLength + dbLength) * gapExtend;
+  score = score - (gapOpen * 2) - distance + scale;
+
+  return score;
+}
+
+int
+global_sse2_byte(int                  queryLength,
+                 unsigned char       *profile,
+                 const unsigned char *dbSeq,
+                 int                  dbLength,
+                 unsigned short       gapOpen,
+                 unsigned short       gapExtend,
+                 unsigned short       ceiling,
+                 unsigned short       bias,
+                 struct f_struct     *f_str)
+{
+  int     i, j;
+
+  int     score;
+  int     scale;
+  int     distance;
+
+  int     offset;
+  int     position;
+
+  int     dup;
+  int     cmp;
+  int     iter;
+    
+  __m128i *pvH;
+  __m128i *pvE;
+
+  __m128i vE, vF, vH;
+  __m128i vHInit;
+  __m128i vHNext;
+  __m128i vFPrev;
+
+  __m128i vBias;
+  __m128i vGapOpen;
+  __m128i vGapExtend;
+  __m128i vCeiling;
+
+  __m128i vScale;
+  __m128i vScaleAmt;
+  __m128i vScaleTmp;
+
+  __m128i vTemp;
+  __m128i vNull;
+
+  __m128i *pvScore;
+
+  scale = 0;
+  iter = (queryLength + 15) / 16;
+  offset = (queryLength - 1) % iter;
+  position = 15 - (queryLength - 1) / iter;
+
+  pvH = (__m128i *)f_str->workspace;
+  pvE = pvH + iter;
+
+  /* Load the bias to all elements of a constant */
+  dup    = (bias << 8) | (bias & 0x00ff);
+  vBias = vec_zero1q();	/* initialize cf Apple Devel smith_waterman_sse2.c */
+  vBias = vec_insert8sh (vBias, dup, 0);
+  vBias = vec_permutelower4sh (vBias, 0);
+  vBias = vec_permute4sw (vBias, 0);
+
+  /* Load gap opening penalty to all elements of a constant */
+  dup      = (gapOpen << 8) | (gapOpen & 0x00ff);
+  vGapOpen = vec_zero1q();	/* initialize cf Apple Devel smith_waterman_sse2.c */
+  vGapOpen = vec_insert8sh (vGapOpen, dup, 0);
+  vGapOpen = vec_permutelower4sh (vGapOpen, 0);
+  vGapOpen = vec_permute4sw (vGapOpen, 0);
+
+  /* Load gap extension penalty to all elements of a constant */
+  dup    = (gapExtend << 8) | (gapExtend & 0x00ff);
+  vGapExtend = vec_zero1q();	/* initialize cf Apple Devel smith_waterman_sse2.c */
+  vGapExtend = vec_insert8sh (vGapExtend, dup, 0);
+  vGapExtend = vec_permutelower4sh (vGapExtend, 0);
+  vGapExtend = vec_permute4sw (vGapExtend, 0);
+
+  /* Generate the ceiling before scaling */
+  dup    = (ceiling << 8) | (ceiling & 0x00ff);
+  vTemp = vec_zero1q();	/* initialize cf Apple Devel smith_waterman_sse2.c */
+  vTemp = vec_insert8sh (vTemp, dup, 0);
+  vTemp = vec_permutelower4sh (vTemp, 0);
+  vTemp = vec_permute4sw (vTemp, 0);
+  vCeiling = vec_compareeq16sb (vTemp, vTemp);
+  vCeiling = vec_subtractsaturating16ub (vCeiling, vTemp);
+  vCeiling = vec_subtractsaturating16ub (vCeiling, vGapOpen);
+
+  /* since we want to use the full range, zero is redefined as */
+  /* 2 * gapOpen.  the lowest scaled score will an insert followed */
+  /* by a delete. */
+  vHInit = vec_shiftrightbytes1q (vGapOpen, 15);
+
+  /* vNull = vec_bitxor1q (vNull, vNull); */
+  vNull = vec_zero1q();	/* initialize cf Apple Devel smith_waterman_sse2.c */
+  vScaleAmt = vNull;
+
+  /* Zero out the storage vector */
+  for (i = 0; i < iter; i++) {
+    vec_store1q (pvH + i, vGapOpen);
+    vec_store1q (pvE + i, vNull);
+  }
+
+  /* initialize F */
+  vF = vNull;
+  vFPrev = vNull;
+
+  /* load and scale H for the next round */
+  vH = vec_load1q (pvH + iter - 1);
+  vH = vec_shiftleftbytes1q (vH, 1);
+  vH = vec_addsaturating16ub (vH, vHInit);
+  vH = vec_addsaturating16ub (vH, vHInit);
+
+  for (i = 0; i < dbLength; ++i) {
+    /* fetch first data asap. */
+    pvScore = (__m128i *) profile + dbSeq[i] * iter;
+
+    vF = vec_bitxor1q (vF, vF);
+
+    vH = vec_max16ub (vH, vFPrev);
+    for (j = 0; j < iter; j++) {
+      /* correct H from the previous columns F */
+      vHNext = vec_load1q (pvH + j);
+      vHNext = vec_max16ub (vHNext, vFPrev);
+
+      /* load and correct E value */
+      vE = vec_load1q (pvE + j);
+      vTemp = vec_subtractsaturating16ub (vHNext, vGapOpen);
+      vE = vec_max16ub (vE, vTemp);
+      vec_store1q (pvE + j, vE);
+
+      /* add score to vH */
+      vH = vec_addsaturating16ub (vH, *pvScore++);
+      vH = vec_subtractsaturating16ub (vH, vBias);
+
+      /* get max from vH, vE and vF */
+      vH = vec_max16ub (vH, vE);
+      vH = vec_max16ub (vH, vF);
+      vec_store1q (pvH + j, vH);
+
+      /* update vF value */
+      vH = vec_subtractsaturating16ub (vH, vGapOpen);
+      vF = vec_max16ub (vF, vH);
+
+      /* load the next h values */
+      vH = vHNext;
+    }
+
+    /* check if we need to scale before the next round */
+    vTemp = vec_subtractsaturating16ub (vCeiling, vF);
+    vTemp = vec_compareeq16sb (vTemp, vNull);
+    cmp  = vec_extractupperbit16sb (vTemp);
+
+    /* broadcast F values */
+    vTemp  = vec_shiftleftbytes1q (vF, 1);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleAmt);
+    vF = vec_max16ub (vF, vTemp);
+
+    vScaleTmp = vec_shiftleftbytes1q (vScaleAmt, 1);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vScaleAmt);
+    vTemp  = vec_shiftleftbytes1q (vF, 2);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 2);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 4);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 4);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 8);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    /* scale if necessary */
+    if (cmp != 0x0000) {
+      vScale = vec_shiftleftbytes1q (vF, 1);
+      vScale = vec_subtractsaturating16ub (vScale, vGapOpen);
+      vScale = vec_subtractsaturating16ub (vScale, vScaleAmt);
+
+      vTemp = vec_shiftleftbytes1q (vScale, 1);
+      vTemp = vec_subtractsaturating16ub (vScale, vTemp);
+      vScaleAmt = vec_addsaturating16ub (vScaleAmt, vTemp);
+      vTemp = vec_shiftleftbytes1q (vScale, 1);
+      vTemp = vec_subtractsaturating16ub (vTemp, vScale);
+      vScaleAmt = vec_subtractsaturating16ub (vScaleAmt, vTemp);
+
+      /* rescale the previous F */
+      vF = vec_subtractsaturating16ub (vF, vScale);
+
+      /* check if we can continue in 8-bits */
+      vTemp = vec_subtractsaturating16ub (vCeiling, vF);
+      vTemp = vec_compareeq16sb (vTemp, vNull);
+      cmp  = vec_extractupperbit16sb (vTemp);
+      if (cmp != 0x0000) {
+        return OVERFLOW_SCORE;
+      }
+
+      /* scale all the vectors */
+      for (j = 0; j < iter; j++) {
+        /* load H and E */
+        vH = vec_load1q (pvH + j);
+        vE = vec_load1q (pvE + j);
+
+        /* get max from vH, vE and vF */
+        vH = vec_subtractsaturating16ub (vH, vScale);
+        vE = vec_subtractsaturating16ub (vE, vScale);
+
+        /* save the H and E */
+        vec_store1q (pvH + j, vH);
+        vec_store1q (pvE + j, vE);
+      }
+
+      /* calculate the final scaling amount */
+      vScale = vScaleAmt;
+      for (j = 0; j < position; ++j) {
+        vScale = vec_shiftleftbytes1q (vScale, 1);
+      }
+      vTemp = vec_unpacklow88sb (vScale, vNull);
+      vScale = vec_unpackhigh88sb (vScale, vNull);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 8);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 4);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 2);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      scale = (int) vec_extract8sh (vScale, 0);
+    }
+
+    /* scale the F value for the next round */
+    vFPrev = vec_shiftleftbytes1q (vF, 1);
+    vFPrev = vec_subtractsaturating16ub (vFPrev, vScaleAmt);
+
+    /* load and scale H for the next round */
+    vH = vec_load1q (pvH + iter - 1);
+    vH = vec_shiftleftbytes1q (vH, 1);
+    vH = vec_subtractsaturating16ub (vH, vScaleAmt);
+    vH = vec_bitor1q (vH, vHInit);
+  }
+
+  /* calculate the max global score */
+  vH = vec_load1q (pvH + offset);
+  vH = vec_max16ub (vH, vF);
+  for (j = 0; j < position; ++j) {
+    vH = vec_shiftleftbytes1q (vH, 1);
+  }
+  score = (int) (unsigned short) vec_extract8sh (vH, 7);
+  score >>= 8;
+
+  /* return largest score */
+  distance = (queryLength + dbLength) * gapExtend;
+  score = score - (gapOpen * 2) - distance + scale;
+
+  return score;
+}
+#else
+
+/* No SSE2 support. Avoid compiler complaints about empty object */
+
+int nw_dummy;
+
+#endif
+
--- /dev/null
+++ src/glocal_vmx.c
@@ -0,0 +1,596 @@
+/******************************************************************
+  Copyright 2010 by Michael Farrar.  All rights reserved.
+  This program may not be sold or incorporated into a commercial product,
+  in whole or in part, without written consent of Michael Farrar.  For 
+  further information regarding permission for use or reproduction, please 
+  contact: Michael Farrar at farrar.michael@gmail.com.
+*******************************************************************/
+
+/*
+  Written by Michael Farrar, 2010.
+  Please send bug reports and/or suggestions to farrar.michael@gmail.com.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+
+#include "defs.h"
+#include "param.h"
+#include "dropgsw2.h"
+#include "global_sse2.h"
+
+#ifdef __SUNPRO_C
+#include <sunmedia_intrin.h>
+#else
+#include "vec128int.h" 
+#endif
+
+#ifdef SW_VMX
+
+static inline __m128i
+max_epu16(__m128i a, __m128i b)
+{
+  a = vec_subtractsaturating8uh (a, b);
+  b = vec_addsaturating8uh (b, a);
+  return b;
+}
+
+int
+glocal_sse2_word(int                  queryLength,
+                 unsigned short      *profile,
+                 const unsigned char *dbSeq,
+                 int                  dbLength,
+                 unsigned short       gapOpen,
+                 unsigned short       gapExtend,
+                 unsigned short       ceiling,
+                 struct f_struct     *f_str)
+{
+  int     i, j;
+
+  int     max;
+  int     score;
+  int     scale;
+  int     temp;
+  int     distance;
+  int     initScale;
+  int     hinit;
+  int     zero;
+
+  int     offset;
+  int     position;
+
+  int     cmp;
+  int     iter;
+    
+  __m128i *pvH;
+  __m128i *pvE;
+
+  __m128i vE, vF, vH;
+  __m128i vHNext;
+  __m128i vFPrev;
+
+  __m128i vGapOpen;
+  __m128i vGapExtend;
+  __m128i vCeiling;
+
+  __m128i vScale;
+  __m128i vScaleAmt;
+  __m128i vScaleTmp;
+
+  __m128i vTemp;
+  __m128i vNull;
+
+  __m128i *pvScore;
+
+  scale = 0;
+  initScale = 0;
+
+  max = 0x80000000;
+  iter = (queryLength + 7) / 8;
+  offset = (queryLength - 1) % iter;
+  position = 7 - (queryLength - 1) / iter;
+
+  pvH = (__m128i *)f_str->workspace;
+  pvE = pvH + iter;
+
+  /* Load gap opening penalty to all elements of a constant */
+  vGapOpen = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapOpen = vec_insert8sh (vGapOpen, gapOpen, 0);
+  vGapOpen = vec_permutelower4sh (vGapOpen, 0);
+  vGapOpen = vec_permute4sw (vGapOpen, 0);
+
+  /* Load gap extension penalty to all elements of a constant */
+  vGapExtend = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapExtend = vec_insert8sh (vGapExtend, gapExtend, 0);
+  vGapExtend = vec_permutelower4sh (vGapExtend, 0);
+  vGapExtend = vec_permute4sw (vGapExtend, 0);
+
+  /* Generate the ceiling before scaling */
+  vTemp = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vTemp = vec_insert8sh (vTemp, ceiling, 0);
+  vTemp = vec_permutelower4sh (vTemp, 0);
+  vTemp = vec_permute4sw (vTemp, 0);
+  vCeiling = vec_compareeq8sh (vTemp, vTemp);
+  vCeiling = vec_shiftrightimmediate8sh (vCeiling, 1);
+  vCeiling = vec_subtractsaturating8sh (vCeiling, vTemp);
+  vCeiling = vec_subtractsaturating8sh (vCeiling, vGapOpen);
+
+  vGapExtend = vec_shiftrightbytes1q (vGapExtend, 14);
+  vNull = vec_compareeq8sh (vTemp, vTemp);
+  vNull = vec_shiftleftimmediate8sh (vNull, 15);
+  vScaleAmt = vec_bitxor1q (vNull, vNull);
+
+  hinit = gapOpen * 2 - SHORT_BIAS;
+  zero = hinit;
+
+  /* Zero out the storage vector */
+  vTemp = vec_addsaturating8sh (vNull, vGapOpen);
+  for (i = 0; i < iter; i++) {
+    vec_store1q (pvH + i, vTemp);
+    vec_store1q (pvE + i, vNull);
+  }
+
+  /* initialize F */
+  vF = vNull;
+  vFPrev = vNull;
+
+  /* load and scale H for the next round */
+  vH = vec_load1q (pvH + iter - 1);
+  vH = vec_shiftleftbytes1q (vH, 2);
+  vH = vec_insert8sh (vH, zero, 0);
+
+  for (i = 0; i < dbLength; ++i) {
+    /* fetch first data asap. */
+    pvScore = (__m128i *) profile + dbSeq[i] * iter;
+
+    vF = vec_insert8sh (vNull, hinit, 0);
+    vF = vec_addsaturating8sh (vF, vGapExtend);
+    vF = vec_subtractsaturating8sh (vF, vGapOpen);
+
+    vH =  vec_max8sh (vH, vFPrev);
+    for (j = 0; j < iter; j++) {
+      /* correct H from the previous columns F */
+      vHNext = vec_load1q (pvH + j);
+      vHNext =  vec_max8sh (vHNext, vFPrev);
+
+      /* load and correct E value */
+      vE = vec_load1q (pvE + j);
+      vTemp = vec_subtractsaturating8sh (vHNext, vGapOpen);
+      vE =  vec_max8sh (vE, vTemp);
+      vec_store1q (pvE + j, vE);
+
+      /* add score to vH */
+      vH = vec_addsaturating8sh (vH, *pvScore++);
+
+      /* get max from vH, vE and vF */
+      vH =  vec_max8sh (vH, vE);
+      vH =  vec_max8sh (vH, vF);
+      vec_store1q (pvH + j, vH);
+
+      /* update vF value */
+      vH = vec_subtractsaturating8sh (vH, vGapOpen);
+      vF =  vec_max8sh (vF, vH);
+
+      /* load the next h values */
+      vH = vHNext;
+    }
+
+    /* check if we need to scale before the next round */
+    vTemp = vec_comparegt8sh (vF, vCeiling);
+    cmp  = vec_extractupperbit16sb (vTemp);
+
+    /* broadcast F values */
+    vF = vec_bitxor1q (vF, vNull);
+
+    vTemp  = vec_shiftleftbytes1q (vF, 2);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleAmt);
+    vF = max_epu16 (vF, vTemp);
+
+    vTemp  = vec_shiftleftbytes1q (vF, 4);
+    vScaleTmp = vec_shiftleftbytes1q (vScaleAmt, 2);
+    vScaleTmp = vec_addsaturating8uh (vScaleTmp, vScaleAmt);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleTmp);
+    vF = max_epu16 (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 4);
+    vScaleTmp = vec_addsaturating8uh (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 8);
+    vTemp = vec_subtractsaturating8uh (vTemp, vScaleTmp);
+    vF = max_epu16 (vF, vTemp);
+
+    /* scale if necessary */
+    if (cmp != 0x0000)  {
+      __m128i vScale1;
+      __m128i vScale2;
+
+      scale = hinit - gapOpen * 2 + SHORT_BIAS;
+      initScale = initScale + scale;
+
+      vScale = vec_shiftleftbytes1q (vF, 2);
+      vScale = vec_subtractsaturating8uh (vScale, vGapOpen);
+      vScale = vec_subtractsaturating8uh (vScale, vScaleAmt);
+      vScale = vec_insert8sh (vScale, scale, 0);
+
+      vTemp = vec_shiftleftbytes1q (vScale, 2);
+      vTemp = vec_subtractsaturating8uh (vScale, vTemp);
+      vScaleAmt = vec_addsaturating8uh (vScaleAmt, vTemp);
+      vTemp = vec_shiftleftbytes1q (vScale, 2);
+      vTemp = vec_subtractsaturating8uh (vTemp, vScale);
+      vScaleAmt = vec_subtractsaturating8uh (vScaleAmt, vTemp);
+      vTemp = vec_subtractsaturating16ub (vTemp, vTemp);
+      vTemp = vec_insert8sh (vTemp, scale, 0);
+      vScaleAmt = vec_subtractsaturating8uh (vScaleAmt, vTemp);
+
+      /* rescale the previous F */
+      vF = vec_subtractsaturating8uh (vF, vScale);
+
+      /* rescale the initial H value */
+      hinit = zero;
+
+      /* check if we can continue in signed 16-bits */
+      vTemp = vec_bitxor1q (vF, vNull);
+      vTemp = vec_comparegt8sh (vTemp, vCeiling);
+      cmp  = vec_extractupperbit16sb (vTemp);
+      if (cmp != 0x0000) {
+        return OVERFLOW_SCORE;
+      }
+
+      vTemp   = vec_addsaturating8sh (vCeiling, vCeiling);
+      vScale1 = vec_subtractsaturating8uh (vScale, vTemp);
+      vScale2 = vec_subtractsaturating8uh (vScale, vScale1);
+
+      /* scale all the vectors */
+      for (j = 0; j < iter; j++) {
+        /* load H and E */
+        vH = vec_load1q (pvH + j);
+        vE = vec_load1q (pvE + j);
+
+        /* get max from vH, vE and vF */
+        vH = vec_subtractsaturating8sh (vH, vScale1);
+        vH = vec_subtractsaturating8sh (vH, vScale2);
+        vE = vec_subtractsaturating8sh (vE, vScale1);
+        vE = vec_subtractsaturating8sh (vE, vScale2);
+
+        /* save the H and E */
+        vec_store1q (pvH + j, vH);
+        vec_store1q (pvE + j, vE);
+      }
+
+      vScale = vScaleAmt;
+      for (j = 0; j < position; ++j) {
+        vScale = vec_shiftleftbytes1q (vScale, 2);
+      }
+
+      /* calculate the final scaling amount */
+      /* vTemp   = vec_bitxor1q (vTemp, vTemp); */
+      vTemp = vec_zero1q();	/* transfered from Apple Devel fix for smith_waterman_sse2.c */
+      vScale1 = vec_unpacklow44sh (vScale, vTemp);
+      vScale2 = vec_unpackhigh44sh (vScale, vTemp);
+      vScale  = vec_add4sw (vScale1, vScale2);
+      vTemp  = vec_shiftrightbytes1q (vScale, 8);
+      vScale = vec_add4sw (vScale, vTemp);
+      vTemp  = vec_shiftrightbytes1q (vScale, 4);
+      vScale = vec_add4sw (vScale, vTemp);
+      scale  = (int) (unsigned short) vec_extract8sh (vScale, 0);
+      temp   = (int) (unsigned short) vec_extract8sh (vScale, 1);
+      scale  = scale + (temp << 16) + initScale;
+    }
+
+    /* scale the F value for the next round */
+    vFPrev = vec_shiftleftbytes1q (vF, 2);
+    vFPrev = vec_subtractsaturating8uh (vFPrev, vScaleAmt);
+    vFPrev = vec_bitxor1q (vFPrev, vNull);
+
+    vF = vec_bitxor1q (vF, vNull);
+
+    vH = vec_load1q (pvH + offset);
+    vH =  vec_max8sh (vH, vFPrev);
+    for (j = 0; j < position; ++j) {
+      vH = vec_shiftleftbytes1q (vH, 2);
+    }
+    score = (int) (signed short) vec_extract8sh (vH, 7);
+    score = score + SHORT_BIAS;
+
+    /* return largest score */
+    distance = (queryLength + i + 1) * gapExtend;
+    score = score - (gapOpen * 2) - distance + scale;
+    max = (max > score) ? max : score;
+
+    /* load and scale H for the next round */
+    hinit += gapExtend;
+    vH = vec_load1q (pvH + iter - 1);
+    vH = vec_shiftleftbytes1q (vH, 2);
+    vH = vec_bitxor1q (vH, vNull);
+    vH = vec_subtractsaturating8uh (vH, vScaleAmt);
+    vH = vec_bitxor1q (vH, vNull);
+    vH = vec_insert8sh (vH, hinit, 0);
+  }
+
+  return max;
+}
+
+int
+glocal_sse2_byte(int                  queryLength,
+                 unsigned char       *profile,
+                 const unsigned char *dbSeq,
+                 int                  dbLength,
+                 unsigned short       gapOpen,
+                 unsigned short       gapExtend,
+                 unsigned short       ceiling,
+                 unsigned short       bias,
+                 struct f_struct     *f_str)
+{
+  int     i, j;
+
+  int     max;
+  int     score;
+  int     scale;
+  int     distance;
+  int     initScale;
+
+  int     offset;
+  int     position;
+
+  int     dup;
+  int     cmp;
+  int     iter;
+    
+  __m128i *pvH;
+  __m128i *pvE;
+
+  __m128i vE, vF, vH;
+  __m128i vHInit;
+  __m128i vHNext;
+  __m128i vFPrev;
+
+  __m128i vBias;
+  __m128i vGapOpen;
+  __m128i vGapExtend;
+  __m128i vCeiling;
+
+  __m128i vScale;
+  __m128i vScaleAmt;
+  __m128i vScaleTmp;
+
+  __m128i vTemp;
+  __m128i vZero;
+  __m128i vNull;
+
+  __m128i *pvScore;
+
+  scale = 0;
+  initScale = 0;
+
+  max = 0x80000000;
+  iter = (queryLength + 15) / 16;
+  offset = (queryLength - 1) % iter;
+  position = 15 - (queryLength - 1) / iter;
+
+  pvH = (__m128i *)f_str->workspace;
+  pvE = pvH + iter;
+
+  /* Load the bias to all elements of a constant */
+  dup    = (bias << 8) | (bias & 0x00ff);
+  vBias = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vBias = vec_insert8sh (vBias, dup, 0);
+  vBias = vec_permutelower4sh (vBias, 0);
+  vBias = vec_permute4sw (vBias, 0);
+
+  /* Load gap opening penalty to all elements of a constant */
+  dup      = (gapOpen << 8) | (gapOpen & 0x00ff);
+  vGapOpen = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapOpen = vec_insert8sh (vGapOpen, dup, 0);
+  vGapOpen = vec_permutelower4sh (vGapOpen, 0);
+  vGapOpen = vec_permute4sw (vGapOpen, 0);
+
+  /* Load gap extension penalty to all elements of a constant */
+  dup    = (gapExtend << 8) | (gapExtend & 0x00ff);
+  vGapExtend = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vGapExtend = vec_insert8sh (vGapExtend, dup, 0);
+  vGapExtend = vec_permutelower4sh (vGapExtend, 0);
+  vGapExtend = vec_permute4sw (vGapExtend, 0);
+
+  /* Generate the ceiling before scaling */
+  dup    = (ceiling << 8) | (ceiling & 0x00ff);
+  vTemp = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vTemp = vec_insert8sh (vTemp, dup, 0);
+  vTemp = vec_permutelower4sh (vTemp, 0);
+  vTemp = vec_permute4sw (vTemp, 0);
+  vCeiling = vec_compareeq16sb (vTemp, vTemp);
+  vCeiling = vec_subtractsaturating16ub (vCeiling, vTemp);
+  vCeiling = vec_subtractsaturating16ub (vCeiling, vGapOpen);
+
+  /* since we want to use the full range, zero is redefined as */
+  /* 2 * gapOpen.  the lowest scaled score will an insert followed */
+  /* by a delete. */
+  vHInit = vec_addsaturating16ub (vGapOpen, vGapOpen);
+  vHInit = vec_shiftrightbytes1q (vHInit, 15);
+  vZero  = vHInit;
+
+  vGapExtend = vec_shiftrightbytes1q (vGapExtend, 15);
+  /*   vNull = vec_bitxor1q (vNull, vNull); */
+  vNull = vec_zero1q();	/* transfered from Apple Devel smith_waterman_sse2.c fix */
+  vScaleAmt = vNull;
+
+  /* Zero out the storage vector */
+  for (i = 0; i < iter; i++) {
+    vec_store1q (pvH + i, vGapOpen);
+    vec_store1q (pvE + i, vNull);
+  }
+
+  /* initialize F */
+  vF = vNull;
+  vFPrev = vNull;
+
+  /* load and scale H for the next round */
+  vH = vec_load1q (pvH + iter - 1);
+  vH = vec_shiftleftbytes1q (vH, 1);
+  vH = vec_bitor1q (vH, vZero);
+
+  for (i = 0; i < dbLength; ++i) {
+    /* fetch first data asap. */
+    pvScore = (__m128i *) profile + dbSeq[i] * iter;
+
+    vF = vec_addsaturating16ub (vHInit, vGapExtend);
+    vF = vec_subtractsaturating16ub (vF, vGapOpen);
+
+    vH = vec_max16ub (vH, vFPrev);
+    for (j = 0; j < iter; j++) {
+      /* correct H from the previous columns F */
+      vHNext = vec_load1q (pvH + j);
+      vHNext = vec_max16ub (vHNext, vFPrev);
+
+      /* load and correct E value */
+      vE = vec_load1q (pvE + j);
+      vTemp = vec_subtractsaturating16ub (vHNext, vGapOpen);
+      vE = vec_max16ub (vE, vTemp);
+      vec_store1q (pvE + j, vE);
+
+      /* add score to vH */
+      vH = vec_addsaturating16ub (vH, *pvScore++);
+      vH = vec_subtractsaturating16ub (vH, vBias);
+
+      /* get max from vH, vE and vF */
+      vH = vec_max16ub (vH, vE);
+      vH = vec_max16ub (vH, vF);
+      vec_store1q (pvH + j, vH);
+
+      /* update vF value */
+      vH = vec_subtractsaturating16ub (vH, vGapOpen);
+      vF = vec_max16ub (vF, vH);
+
+      /* load the next h values */
+      vH = vHNext;
+    }
+
+    /* check if we need to scale before the next round */
+    vTemp = vec_subtractsaturating16ub (vCeiling, vF);
+    vTemp = vec_compareeq16sb (vTemp, vNull);
+    cmp  = vec_extractupperbit16sb (vTemp);
+
+    /* broadcast F values */
+    vTemp  = vec_shiftleftbytes1q (vF, 1);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleAmt);
+    vF = vec_max16ub (vF, vTemp);
+
+    vScaleTmp = vec_shiftleftbytes1q (vScaleAmt, 1);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vScaleAmt);
+    vTemp  = vec_shiftleftbytes1q (vF, 2);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 2);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 4);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    vTemp = vec_shiftleftbytes1q (vScaleTmp, 4);
+    vScaleTmp = vec_addsaturating16ub (vScaleTmp, vTemp);
+    vTemp  = vec_shiftleftbytes1q (vF, 8);
+    vTemp = vec_subtractsaturating16ub (vTemp, vScaleTmp);
+    vF = vec_max16ub (vF, vTemp);
+
+    /* scale if necessary */
+    if (cmp != 0x0000) {
+      vHInit = vec_subtractsaturating16ub (vHInit, vGapOpen);
+      vHInit = vec_subtractsaturating16ub (vHInit, vGapOpen);
+      scale = vec_extract8sh (vHInit, 0);
+      initScale = initScale + scale;
+
+      vScale = vec_shiftleftbytes1q (vF, 1);
+      vScale = vec_subtractsaturating16ub (vScale, vGapOpen);
+      vScale = vec_subtractsaturating16ub (vScale, vScaleAmt);
+      vScale = vec_bitor1q (vScale, vHInit);
+
+      vTemp = vec_shiftleftbytes1q (vScale, 1);
+      vTemp = vec_subtractsaturating16ub (vScale, vTemp);
+      vScaleAmt = vec_addsaturating16ub (vScaleAmt, vTemp);
+      vTemp = vec_shiftleftbytes1q (vScale, 1);
+      vTemp = vec_subtractsaturating16ub (vTemp, vScale);
+      vScaleAmt = vec_subtractsaturating16ub (vScaleAmt, vTemp);
+      vScaleAmt = vec_subtractsaturating16ub (vScaleAmt, vHInit);
+
+      /* rescale the previous F */
+      vF = vec_subtractsaturating16ub (vF, vScale);
+
+      /* rescale the initial H value */
+      vHInit = vZero;
+
+      /* check if we can continue in 8-bits */
+      vTemp = vec_subtractsaturating16ub (vCeiling, vF);
+      vTemp = vec_compareeq16sb (vTemp, vNull);
+      cmp  = vec_extractupperbit16sb (vTemp);
+      if (cmp != 0x0000) {
+        return OVERFLOW_SCORE;
+      }
+
+      /* scale all the vectors */
+      for (j = 0; j < iter; j++) {
+        /* load H and E */
+        vH = vec_load1q (pvH + j);
+        vE = vec_load1q (pvE + j);
+
+        /* get max from vH, vE and vF */
+        vH = vec_subtractsaturating16ub (vH, vScale);
+        vE = vec_subtractsaturating16ub (vE, vScale);
+
+        /* save the H and E */
+        vec_store1q (pvH + j, vH);
+        vec_store1q (pvE + j, vE);
+      }
+
+      /* calculate the final scaling amount */
+      vScale = vScaleAmt;
+      for (j = 0; j < position; ++j) {
+        vScale = vec_shiftleftbytes1q (vScale, 1);
+      }
+      vTemp = vec_unpacklow88sb (vScale, vNull);
+      vScale = vec_unpackhigh88sb (vScale, vNull);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 8);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 4);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      vTemp = vec_shiftrightbytes1q (vScale, 2);
+      vScale = vec_addsaturating8sh (vScale, vTemp);
+      scale = (int) vec_extract8sh (vScale, 0);
+      scale = scale + initScale;
+    }
+
+    /* scale the F value for the next round */
+    vFPrev = vec_shiftleftbytes1q (vF, 1);
+    vFPrev = vec_subtractsaturating16ub (vFPrev, vScaleAmt);
+
+    /* calculate the max glocal score for this column */
+    vH = vec_load1q (pvH + offset);
+    vH = vec_max16ub (vH, vF);
+    for (j = 0; j < position; ++j) {
+      vH = vec_shiftleftbytes1q (vH, 1);
+    }
+    score = (int) (unsigned short) vec_extract8sh (vH, 7);
+    score >>= 8;
+
+    /* return largest score */
+    distance = (queryLength + i + 1) * gapExtend;
+    score = score - (gapOpen * 2) - distance + scale;
+    max = (max > score) ? max : score;
+
+    /* load and scale H for the next round */
+    vHInit = vec_addsaturating16ub (vHInit, vGapExtend);
+    vH = vec_load1q (pvH + iter - 1);
+    vH = vec_shiftleftbytes1q (vH, 1);
+    vH = vec_subtractsaturating16ub (vH, vScaleAmt);
+    vH = vec_bitor1q (vH, vHInit);
+  }
+
+  return max;
+}
+#else
+
+/* No SSE2 support. Avoid compiler complaints about empty object */
+
+int nw_dummy;
+
+#endif
+
